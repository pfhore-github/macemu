<!DOCTYPE html>
<html lang="ja">
  <head>
	<meta charset="UTF-8" />
	<title>M68K macintosh hardware reference SCC</title>
	<link rel="stylesheet" href="style.css" />
  </head>
  <body>
	<h2 id="scc">SCC</h2>
	<p>see also <a href="rs422.html">serial port</a>.</p>
	<h3>Pin</h3>
	<dl>
	  <dt>TxD(出力)</dt><dd>出力データ</dd>
	  <dt>RTS(出力)</dt><dd>データ出力の有効化</dd>
	  <dt>RTxC(入力)</dt><dd>VIA1.3が1の時は3.672MHz clock、それ以外はGPiA信号</dd>
	  <dt>CTS(入力)</dt><dt>TRxC(入力)</dt><dd>HSKiA(ハンドシェイク・入力)信号</dd>
	  <dt>DCD(入力)</dt><dd>GPi信号</dd>
	  <dt>DTR(出力)</dt><dd>HSKoA(ハンドシェイク・出力)信号</dd>
	  <dt>REQ(出力：ターゲットはVIA1)</dt><dd>SCC wait/request</dd>
	</dl>
	<h3>外部レジスタ</h3>
	<dl>
	  <dt>#00</dt><dd>プリンタポートコマンド</dd>
	  <dt>#02</dt><dd>モデムポートコマンド</dd>
	  <dt>#04</dt><dd>プリンタポートデータ(RR8と同じ)</dd>
	  <dt>#06</dt><dd>モデムポートデータ(RR8と同じ)</dd>
	</table>
	<h3>I/O転送方法</h3>
	<h4>ポーリング</h4>
	<p>これは、実装する最も簡単なモードです。 ソフトウェアは、SCCをポーリングして、SCCからデータを入力または出力するタイミングを決定する必要があります。 このモードでは、MIE（WR9、ビット3）、およびウェイト/ DMAリクエストイネーブル（WR1、ビット7）が両方とも0にリセットされ、割り込みまたはDMAリクエストを無効にします。 次に、ソフトウェアはRR0をポーリングして、受信バッファー、送信バッファー、および外部ステータスのステータスを判断する必要があります。</p>

	<p>ポーリングシーケンス中に、読み取りレジスタ0のステータスが各チャネルで検査されます。 このレジスタは、受信または送信データ転送が必要かどうか、およびエラーなどの特別な条件が存在するかどうかを示します。</p>

	<p>このI/O転送方法では、割り込みが回避されるため、すべての割り込み機能を無効にする必要があります。 割り込みが有効になっていない場合、この動作モードでは、データハンドラルーチンにジャンプする前に、読み取りレジスタ0の読み取りサイクルを開始して、着信文字を検出する必要があります。</p>
	<h4>割り込み</h4>
	<p>SCCの2つのチャネルにはそれぞれ3つの割り込みソースが含まれ、合計6つの割り込みソースになります。 これらの3つの割り込みソースは、1）レシーバー、2）トランスミッター、および3）外部/ステータス条件です。 さらに、これらの割り込みを引き起こす可能性のあるいくつかの条件があります。 <a href="#scc_int">図</a>は、各割り込みソースのさまざまな条件を示しており、それぞれがプログラム制御下で有効になっています。 表に示すように、チャネルAはチャネルBよりも優先度が高く、受信、送信、および外部/ステータス割り込みがそれぞれ優先されます。SCCは、Z85X30のすべてのPCLKサイクルおよびZ80X30の/ASで割り込みステータスを内部的に更新します。</p>
	<div>
	  <img style="float:left;" id="scc_int" src="scc_int.png" alt="ESCC Interrupt Sources">
	<table><caption>割り込み情報源優先順位</caption>
	  <tr><td>受信チャンネルA</td><td>最高</td></tr>
	  <tr><td>送信チャンネルA</td><td>↑</td></tr>
	  <tr><td>外部/ステータス条件A</td><td></td></tr>
	  <tr><td>受信チャンネルB</td><td></td></tr>
	  <tr><td>送信チャンネルB</td><td>↓</td></tr>
	  <tr><td>外部/ステータス条件A</td><td>最低</td></tr>
	</table>
	</div>
	<p>特別な条件は、受信FIFOオーバーラン、CRC /フレーミングエラー、フレームの終わり、およびパリティです。 パリティが特別な条件として含まれているかは、WR1 D2に依存します。 特別条件ステータスはRR1から読み取ることができます。</p>

	<p>送信バッファが空になるたびにIPビットを設定します。 つまり、送信IPを設定する前に、送信バッファがいっぱいでした。</p>

	<p>送信割り込みの詳細については、<a href="#">送信割り込みと送信バッファエンプティビット</a>を参照してください。</p>

	<p>外部/ステータス割り込みには、WR15で個別に有効にできるいくつかのソースがあります。 ソースは、ゼロカウント、/ DCD、同期/ハント、/ CTS、トランスミッタアンダーラン/ EOM、および中断/中止です。</p>
	<h3 style="clear: left;">割り込み制御</h3>
	<p>すべてのSCC割り込みを有効または無効にするMIEビットに加えて、SCC内の各割り込みソースには、3つの制御/ステータスビットが関連付けられています。 それらは、Interrupt Enable（IE）、Interrupt Pending（IP）、Interrupt-Under-Service（IUS）です。 39ページの図は、SCC割り込み構造を示しています。</p>
	<h4>Master Interrupt Enable Bit(MIE)</h4>
	<p>SCCが割り込みを生成できるようにするには、マスター割り込み有効化（MIE）ビットWR9 D3を設定する必要があります。 SCCレジスタを初期化し、個々の割り込みを有効にした後、MIEビットを設定する必要があります。 SCCは、有効な割り込み条件の1つが検出されたことを検出した場合にのみ、オープンドレイン状態から/ INTピンをLowにアサートして割り込みを要求します。</p>
	<h4>Interrupt Enable Bit</h4>
	<p>割り込みイネーブル（IE）ビットは、SCCの各割り込みソースからの割り込み要求を制御します。 割り込みソースのIEビットが1に設定されている場合、必要な条件がすべて満たされていれば、そのソースが割り込み要求を生成する可能性があります。 IEビットがリセットされると、そのソースによって割り込み要求は生成されません。 送信割り込みIEビットはWR1 D1です。 受信割り込みIEビットはWR1 D3およびD4です。 外部ステータス割り込みは、WR1 D0でマスター外部ステータス割り込みを有効にして、WR15で個別に有効にします。 注意：割り込みが発生するには、MIEビットWR9 D3をセットする必要があります。</p>
	<h4>Interrupt Pending Bit</h4>
	<p>特定の割り込みソースの割り込み保留（IP）ビットは、SCC内の割り込み条件の存在によって設定されます。 これは、プロセッサによって直接リセットされるか、またはプロセッサが取る可能性のあるアクションによって間接的にリセットされます。 対応するIEビットが設定されていない場合、その割り込みソースのIPは決して設定されません。SCCのIPビットはRR3経由でのみ読み取られます。</p>
	<h4>Interrupt-Under-Service Bit</h4>
	<p>サービス割り込み（IUS）ビットは、プロセッサから完全に隠されています。 IUSビットは、優先順位が最も高いIPの割り込み確認サイクル中に設定されます。 CMOSでは、IUSビットは、/INTACKピンを使用したハードウェアアクノレッジサイクル、またはWR9 D5 = 1の場合はソフトウェアを介してRR2を読み取ることによって設定できます。</p>

	<p>IUSビットは、内部および外部デイジーチェーン割り込みの動作を制御します。 内部デイジーチェーンは、割り込みの6つのソースを固定された順序でリンクし、各ソースのIUSビットをチェーンします。 内部IUSビットが設定されている場合、優先度の低い割り込み要求はすべてマスクされます。 割り込み承認サイクルの間、IPビットもデイジーチェーンにゲートされます。 これにより、選択された最も優先度の高いIPにIUSビットが設定されます。 割り込みサービスルーチンの最後に、プロセッサはWR0で最も高いIUSのリセットコマンドを発行して、優先度の低い割り込みを再度有効にする必要があります。 これは、ソフトウェアまたはハードウェアのリセットを除いて、IUSビットがリセットされる唯一の方法です。</p>
	<h3>内部レジスタ</h3>
	<table>
	  <tr>
		<th >7(#80)</th><th >6(#40)</th><th >5(#20)</th><th >4(#10)</th>
		<th >3(#08)</th><th >2(#04)</th><th >1(#02)</th><th >0(#01)</th>
	  </tr>
	  <tr><th>0</th>
		<td colspan="2">
		  <table><caption>CRC初期化</caption>
			<tr><th>code</th><th>動作</th></tr>
			<tr><th>00</th><td class="na"></td></tr>
			<tr><th>01</th><td>受信CRCチェッカの初期化</td></tr>
			<tr><th>10</th><td>送信CRC生成器初期化</td></tr>
			<tr><th>11</th><td>送信EOM/バッファアンダーラン状態初期化</td></tr>
		  </table>
		</td>
		<td colspan="3">
		  <table><caption>汎用コマンド</caption>
			<tr><th>code</th><th>op</th></tr>
			<tr><th>000</th><td class="na"></td></tr>
			<tr><th>001</th><td>上位レジスタ選択</td></tr>
			<tr><th>010</th><td>外部割り込みのラッチ状態を初期化</td></tr>
			<tr><th>011</th><td>SDLC中止</td></tr>
			<tr><th>100</th><td>先頭文字到着による割り込みを有効化</td></tr>
			<tr><th>101</th><td>送信割り込み保留状態リセット</td></tr>
			<tr><th>110</th><td>エラー状態初期化</td></tr>
			<tr><th>111</th><td>reset highest IUS</td></tr>
		  </table>
		</td>
		<td colspan="2">レジスタ番号</td>
	  </tr>
	  <tr><th>1</th>
		<td>WAIT/DMA Request Enable</td>
		<td>WAIT/DMA Request Function</td>
		<td>WAIT/DMA Request On Recv/Xfer</td>
		<td colspan="2">
		  <table><caption>recv interrupt modes</caption>
			<tr><th>CODE</th><th>meaning</th></tr>
			<tr><th>00</th><td>Recv interrupt disable</td></tr>
			<tr><th>01</th><td>Recv interrupt on first char or special cond</td></tr>
			<tr><th>10</th><td>Recv interrupt on all chars or special cond</td></tr>
			<tr><th>11</th><td>Recv interrupt on special cond</td></tr>
		  </table>
		</td>
		<td>parity is special condtion</td>
		<td>transmitter interrupt enable</td>
		<td>external/status master interrupt enable</td>
	</table>
	<table><caption>Internal(R)</caption>
	  <tr><th rowspan="2">reg</th><th colspan="8">W</th>
	  <tr>
		<th>7(#80)</th><th>6(#40)</th><th>5(#20)</th><th>4(#10)</th><th>3(#08)</th><th>2(#04)</th><th>1(#02)</th><th>0(#01)</th>
	  </tr>
	  <tr><th>0</th>
		<td colspan="2">
		  <table><caption>CRC reset</caption>
			<tr><th>code</th><th>op</th></tr>
			<tr><th>00</th><td>do noting</td></tr>
			<tr><th>01</th><td>reset CRC checker</td></tr>
			<tr><th>10</th><td>reset transmit CRC generator</td></tr>
			<tr><th>11</th><td>reset transmit underrun/EOM latch</td></tr>
		  </table>
		</td>
		<td colspan="3">
		  <table><caption>CRC CMD</caption>
			<tr><th>code</th><th>op</th></tr>
			<tr><th>000</th><td>do noting</td></tr>
			<tr><th>001</th><td>set high register</td></tr>
			<tr><th>010</th><td>reset external/status interrupt</td></tr>
			<tr><th>011</th><td>send abort</td></tr>
			<tr><th>100</th><td>enable interrupt on next character</td></tr>
			<tr><th>101</th><td>reset Transmit interrupt pending</td></tr>
			<tr><th>110</th><td>error reset</td></tr>
			<tr><th>111</th><td>reset highest IUS</td></tr>
		  </table>
		</td>
		<td colspan="3">register number</td>
		<td>break/abort</td>
		<td>Transmit underrun/EOM</td>
		<td>CTS(HSKiA pin)</td>
		<td>sync/hunt</td>
		<td>DCD</td>
		<td>Tranmit buffer empty</td>
		<td>zero count</td>
		<td>recievec character avlaiable</td>
	  </tr>
	  <tr><th>1</th>
		<td>WAIT/DMA Request Enable</td>
		<td>WAIT/DMA Request Function</td>
		<td>WAIT/DMA Request On Recv/Xfer</td>
		<td colspan="2">
		  <table><caption>recv interrupt modes</caption>
			<tr><th>CODE</th><th>meaning</th></tr>
			<tr><th>00</th><td>Recv interrupt disable</td></tr>
			<tr><th>01</th><td>Recv interrupt on first char or special cond</td></tr>
			<tr><th>10</th><td>Recv interrupt on all chars or special cond</td></tr>
			<tr><th>11</th><td>Recv interrupt on special cond</td></tr>
		  </table>
		</td>
		<td>parity is special condtion</td>
		<td>transmitter interrupt enable</td>
		<td>external/status master interrupt enable</td>
		<td>end of frame status(SDLC only)</td>
		<td>CRC(sync/SDLC)/framing error(async) status</td>
		<td>receiver overrun error status</td>
		<td>parity error status</td>
		<td colspan="3">residue codes (SDLC)</td>
		<td>all sent (async)</td>
	</table>
  </body>
</html>
